- `docker pull postgres`
- `docker run --name alembic-demo -p 8100:5432 -e POSTGRES_PASSWORD=postgres -d postgres` : To run postgres container with a password and expose port 5432 of the container to host machine.
- `docker exec it alembic-demo sh` : Inside of having the run command on psql in alembic-demo container I will just enter the container and run the commands directly.

- Create a python virtual environemnt, activate it and install alembic and psycopg2 `pip install alembic psycopg2`

## Alembic

- In alembic we start by creating a migration environment, a directory of scripts specific to your application, it is created just once. After that it is maintained along with the application source code.
- `alembic init <environment_name>` : Create initial migration environment. This will create alembic.ini file which is the file alembic file looks for when alembic command in invoked. It will also create directory with the environment name. Files created by alembic init : ![image](https://i.imgur.com/ZibpCvd.png)

- env.py : Python script that is run anytime alembic commands are invoked, this file uses sqlalchemy to connect to the database and start a transaction.
- Now we need to tell alembic how to connect to the database running in our docker container.
  - Change this variables : sqlalchemy.url = driver://user:pass@localhost/dbname
  - I set it to `sqlalchemy.url = postgresql://postgres:postgres@localhost:8100/postgres` had to specify port as well because I change port from default 5432 to 8100.
- `alembic revision -m "Message"`
  - Used after modifying the database schema or sqlAlchemy models to create a new revision.
  - Why do we alembic revision when making changes to the database schema?
    - Track database schema changes over time
    - Safely deploy changes to production, manually running ALTER TABLE in production risks errors, with alembic we can track changes, deploy changes safely and downgrade if needed.
    - Autogenerate Migrations for Models : use --autogenerate `alembic revision --autogenerate -m "Message"`

## Versions

- Under versions directory we have a bunch of files that are created by alembic, each file is a revision. Everyone you run alembic revision it will create a new revision. Under revision we have upgrade and downgrade method. Which define how to upgrade and downgrade (revert changes) the database.
- `alembic revision --autogenerate -m "Message"` : Create a new revision with autogenerated upgrade and downgrade methods.
- These versions are used to upgrade and downgrade the database. Using `alembic upgrade` command

## Upgrade

- `alembic upgrade head` : Upgrade the database using the upgrade method from the latest revision.

  - Alternatively we can specify a revision number to upgrade to a specific revision.

- `alembic downgrade <revision_number>` : Downgrade the database using the revision number. Runs all downgrade method from current revision to the revision number (including the revision number's downgrade).
  - `alembic downgrade base` : Downgrade to the base revision (i.e. before the first upgrade).
  - `alembic downgrade -<x>` : Relative downgrade, downgrades the x number of times.
- `alembic history` : Show the revision history of the database.
- `alembic current` : Show the current revision of the database.

## Alembic setup with Models

`alembic downgrade base` : Revert back to initial database state.

- Delete version files from both version and **pycache** directories.
- Create models.py file and define models.
- Now we need to make alembic aware of our models, we do this by modifying the env.py file.
  - ```python
    env.py
        from models import Base
        target_metadata = Base.metadata
    ```
